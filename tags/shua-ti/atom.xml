<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 刷题 | ArtemisYY's Blog]]></title>
  <link href="http://ArtemisYY.github.io/tags/shua-ti/atom.xml" rel="self"/>
  <link href="http://ArtemisYY.github.io/"/>
  <updated>2013-08-04T19:54:20+08:00</updated>
  <id>http://ArtemisYY.github.io/</id>
  <author>
    <name><![CDATA[ArtemisYY]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Longest Consecutive Sequence]]></title>
    <link href="http://ArtemisYY.github.io/blog/2013/08/04/longest-consecutive-sequence/"/>
    <updated>2013-08-04T19:46:00+08:00</updated>
    <id>http://ArtemisYY.github.io/blog/2013/08/04/longest-consecutive-sequence</id>
    <content type="html"><![CDATA[<p>Leetcode 128， 无序数组求最长连续序列的长度。要求时间复杂度位O(log N).    <br/>
最直观的想法，先排序，然后求最长连续序列的长度。但是时间复杂度位O(N log N). <!--more--></p>

<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>

<p>For example,
Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.  <br/>
Your algorithm should run in O(n) complexity.</p>

<p>解题思路：从当前元素分别递减和递增寻找，一次就把包含当前原色连续序列找全。找全后，清空所有找到的元素，保证下次不会重复寻找。如何从O(1）时间内找到一个数，hash或者set。</p>

<p>涉及到“在未排序集合中寻找有序集合”的题目，可以考虑本题的思路。</p>

<p>==============================================================================</p>

<p>1.O(N log N) 排序，没搞明白为什么runtime error，超时？可是有人说用排序也过了的啊～  <br/>
```java leetcode128.java
public int longestConsecutive(int[] num) {</p>

<pre><code>quickSort(num, 0, num.length-1);
int maxLength = 1;
int tempLength = 1;
for( int i = 1; i&lt; num.length; i++)
{
    if(num[i] == num[i-1]+1)
    {
        tempLength++;
        maxLength = Math.max(maxLength, tempLength);
        continue;
    }
    else{
        if( num[i] == num[i-1])
            continue;
    }
    tempLength = 1;
    }
return maxLength;
</code></pre>

<p>}</p>

<p>public void quickSort(int[] num, int left, int right)
{</p>

<pre><code>if( left &lt; right)
{
    int position = Partition(num, left, right);
    quickSort(num, left, position-1);
    quickSort(num, position+1, right);
}
</code></pre>

<p>}</p>

<p>public int Partition(int[] num, int left, int right) {</p>

<pre><code>int temp = num[left];
int tempPosition = left;
for( int i= left+1; i&lt;= right; i++)
{
    if( num[i] &lt; temp)
    {
        tempPosition++;
        if( tempPosition !=i )
        {
                num[i] = num[i] + num[tempPosition];
                num[tempPosition] = num[i] - num[tempPosition];
                num[i] = num[i] - num[tempPosition];
        }
    }
}
num[left] = num[tempPosition];
num[tempPosition] = temp;
return tempPosition;
</code></pre>

<p>}
<code>   
2. O(N)思路很巧妙，以后记得借鉴。   
</code>java leetcode128.java
public int longestConsecutive(int[] num) {</p>

<pre><code>Set&lt;Integer&gt; save = new HashSet&lt;Integer&gt;();
for(int i : num)
{
    save.add(i);
}

int maxLength = 1;
for(int i : num)
{
    maxLength = Math.max(maxLength, getLength(save, i, false)+getLength(save, i+1, true));
}
return maxLength;
</code></pre>

<p>}</p>

<p>public int getLength(Set<Integer> save, int i, boolean ascending)
{</p>

<pre><code>int count = 0;
while(save.contains(i))
{
    count++;
    save.remove(i);
    if(ascending)
        i++;
    else i--;
}
return count;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Path Sum]]></title>
    <link href="http://ArtemisYY.github.io/blog/2013/08/04/path-sum/"/>
    <updated>2013-08-04T16:05:00+08:00</updated>
    <id>http://ArtemisYY.github.io/blog/2013/08/04/path-sum</id>
    <content type="html"><![CDATA[<p>两道题(Leetcode 112-113) 二叉树从根结点到叶结点求和问题，递归求解。</p>

<ol>
<li>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</li>
<li>Given a binary tree and a sum, find all root-to-leaf paths where each path&rsquo;s sum equals the given sum.<!--more--></li>
</ol>


<p>For example:
Given the below binary tree and sum = 22,</p>

<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1
</code></pre>

<ol>
<li>return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.</li>
<li>return[ [5,4,11,2], [5,8,4,5]]</li>
</ol>


<p>=================================================================================
```java Leetcode112.java
 public boolean hasPathSum(TreeNode root, int sum) {</p>

<pre><code> if( root == null)
    return false;
 else if( root.left == null &amp;&amp; root.right == null )
 {
    return (root.val == sum);
 }
 else {
    return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);
 }
</code></pre>

<p>}
```</p>

<p>```java Leetcode113.java
public ArrayList&lt;ArrayList<Integer>> pathSum(TreeNode root, int sum) {</p>

<pre><code>ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
helpPathSum(root, sum, new ArrayList&lt;Integer&gt;(), result);
return result;
</code></pre>

<p>}</p>

<p>public void helpPathSum(TreeNode root, int sum, ArrayList<Integer> tempPath, ArrayList&lt;ArrayList<Integer>> result)
{</p>

<pre><code>if( root == null) return;
tempPath.add(root.val);
if( root.left == null &amp;&amp; root.right == null){
    if( root.val == sum)
    {
        ArrayList&lt;Integer &gt; path = new ArrayList&lt;Integer&gt;(tempPath);//必须拷贝一份新的。
        result.add(path);//找到路径，添加。
    }

}else {
    helpPathSum(root.left, sum-root.val, tempPath, result);
    helpPathSum(root.right, sum - root.val, tempPath, result);
}
tempPath.remove(tempPath.size()-1);//返回树上一层
</code></pre>

<p>}
```</p>

<p>Reference： <a href="http://discuss.leetcode.com/questions/279/path-sum-ii">http://discuss.leetcode.com/questions/279/path-sum-ii</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Best Time to Buy and Sell Stock]]></title>
    <link href="http://ArtemisYY.github.io/blog/2013/07/31/best-time-to-buy-and-sell-stock/"/>
    <updated>2013-07-31T17:02:00+08:00</updated>
    <id>http://ArtemisYY.github.io/blog/2013/07/31/best-time-to-buy-and-sell-stock</id>
    <content type="html"><![CDATA[<p>三道题(Leetcode 121 —— 123) <br/>
Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>

<ul>
<li>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</li>
<li>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>
<li>Design an algorithm to find the maximum profit. You may complete at most two transactions.<!--more--></li>
</ul>


<p>=================================================================================
解题思路：       <br/>
(1) 寻找序列整数的最大差，且小数出现在前面。 <br/>
(2) 寻找连续递增空间。 <br/>
(3) 将数组(0——i, i+1——n-1)两部分，left[i] 和 right[j]分别记录0——i, j——n-1两部分可获取的最大利润</p>

<p>```java Leetcode121.java
//elegent code
public int maxProfit(int[] prices) {</p>

<pre><code> if(prices.length &lt; 2)
     return 0;
 int max = 0;
 int distance = 0;
 for( int i = 1; i &lt; prices.length; i++)
 {
     distance = prices[i] - prices[i-1] + Math.max(distance, 0);
     max = (distance &gt; max) ? distance :max;
 }
return max;
</code></pre>

<p>}
// my ugly code
public int maxProfit(int[] prices) {</p>

<pre><code>  if(prices.length &lt; 2)
         return 0;
  int max = 0;
  int min = prices[0];
  for( int i = 1; i &lt; prices.length; i++)
  {
     if(prices[i] - min &gt; max)
     max = prices[i] - min;
     min = (prices[i] &lt; min ) ? prices[i] : min;
  }
  return max;
</code></pre>

<p> }
<code>
</code>java Leetcode122.java
public int maxProfit(int[] prices) {</p>

<p>  if(prices.length &lt; 2)</p>

<pre><code> return 0;
</code></pre>

<p>  int max = 0;
  int start = prices[0];
  for( int i = 1; i &lt; prices.length; i++ )
  {</p>

<pre><code>  if( prices[i]- prices[i-1] &gt; 0)
     continue;
  max += prices[i-1] - start;
  start = prices[i];
</code></pre>

<p>  }</p>

<p>  max += prices[prices.length &ndash; 1] -start;
  return max;</p>

<pre><code>}
</code></pre>

<p>}
<code>
</code>java Leetcode123.java
public int maxProfit(int[] prices) {</p>

<pre><code>if( prices.length &lt; 2)
return 0;
int left[] = new int[prices.length];
int right[] = new int [prices.length];
int min = prices[0];
int maxP = 0;
left[0] = 0;
for( int i = 1; i &lt; prices.length; i++)
{
    left[i] = Math.max(left[i-1], prices[i] - min) ;
    if( prices[i] &lt; min)
        min = prices[i];
}
right[prices.length - 1] = 0;
int max = prices[prices.length -1];
for( int i = prices.length-2; i&gt;=0; i--)
{
right[i] = Math.max(right[i+1], max - prices[i] ) ;
if( prices[i] &gt; max)
    max = prices[i];
}

maxP = Math.max(left[prices.length -1], right[0]);
for( int i=0; i&lt; prices.length-2; i++)
    if(maxP &lt; left[i]+ right[i+1])
        maxP = left[i]+ right[i+1];

return maxP;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sum Root to Leaf Numbers]]></title>
    <link href="http://ArtemisYY.github.io/blog/2013/07/31/sum-root-to-leaf-numbers/"/>
    <updated>2013-07-31T16:34:00+08:00</updated>
    <id>http://ArtemisYY.github.io/blog/2013/07/31/sum-root-to-leaf-numbers</id>
    <content type="html"><![CDATA[<p>(Leetcode 129)   <br/>
Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. <br/>
An example is the root-to-leaf path 1->2->3 which represents the number 123.
Find the total sum of all root-to-leaf numbers. <br/>
For example,</p>

<pre><code>  1
 / \
2   3
</code></pre>

<p>The root-to-leaf path 1->2 represents the number 12. <br/>
The root-to-leaf path 1->3 represents the number 13. <br/>
Return the sum = 12 + 13 = 25.   <!--more--></p>

<p>===================================================================================
解题思路： 递归求解。叶结点返回sum，否则每下一层sum*10+node.val. 简单题.</p>

<p>```java Leetcode129.java
public int sumNumbers(TreeNode root) {</p>

<pre><code>        // Start typing your Java solution below
        // DO NOT write main() function


     int prefix = 0;
     return calculateSum( root,  prefix );

    }
</code></pre>

<p>int calculateSum(TreeNode root, int prefix)
{</p>

<pre><code>if( root == null)
   return 0;

prefix = prefix*10 + root.val;
if( root.left == null &amp;&amp; root.right == null)
   return prefix;
return calculateSum(root.left, prefix) + calculateSum(root.right, prefix);
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Palindrome Partitioning]]></title>
    <link href="http://ArtemisYY.github.io/blog/2013/07/27/leetcode-131-and-132-palindrome-partitioning/"/>
    <updated>2013-07-27T17:51:00+08:00</updated>
    <id>http://ArtemisYY.github.io/blog/2013/07/27/leetcode-131-and-132-palindrome-partitioning</id>
    <content type="html"><![CDATA[<p>两道题(Leetcode 121 &ndash; 123).<br/>
Given a string s, partition s such that every substring of the partition is a palindrome.<br/>
   1. Return all possible palindrome partitioning of s. <br/>
   2. Return the minimum cuts needed for a palindrome partitioning of s.</p>

<pre><code>For example, given s = "aab",  
1. Return [["aa","b"],["a","a","b"]]  
2. Return 1 since the palindrome partitioning ["aa","b"] could be produced using 1 cut.
</code></pre>

<!--more-->


<p>===================================================================================
解题思路，动态规划：(和矩阵链相乘时，使乘法次数达到最小的运算顺序思路类似。)<br/>
这题比较有意思的是，两个动态规划的思路嵌在一起了。   <br><br>
  1. 用isPa[i][j]矩阵记录S.subString(i,j)是否为回文。 <br/>
  2. 针对不同的问题，根据isPa[i][j]矩阵输出不同结果： <br/>
   + 详细分割串（递归输出）：Start 到 End的所有回文分割串是Start到i,i到End的所有回文分割方法的组合。<br/>
   + 最小分割次数（DP）：用dpMin[j]记录s.subString(0,j)的最小分割次数。</p>

<pre><code>  dpMin[j] = Min{dpMin[j], 1+dpMin[i-1]} （i在0——j， 且s.subString(i,j)为回文）
</code></pre>

<p>===================================================================================</p>

<ul>
<li><p>注意递归输出所有可能的划分时的思路。
```java Leetcode131.java
public class Palindrome {</p>

<p>  public ArrayList&lt;ArrayList<String>> partition(String s) {
      if( s == null || s.length() == 0)
          return new ArrayList&lt;ArrayList<String>>();</p>

<pre><code>  boolean [][] isPa = new boolean[s.length()][s.length()];
  for( int i=0; i&lt;s.length(); i++)
  {
      isPa[i][i] = true;
  }
  for( int d = 1; d &lt; s.length(); d++)
      for( int i = 0; i &lt; s.length()-d; i++)
      {
          int j = i+d;
          if ( d == 1 )
          {
              isPa[i][j] = (s.charAt(i) == s.charAt(j));
          }
          else {
              isPa[i][j] = (s.charAt(i)== s.charAt(j)) &amp;&amp; isPa[i+1][j-1];
          }
      }
  return printResult(s, 0, isPa);
</code></pre>

<p>  } <br/>
  public ArrayList&lt;ArrayList<String>> printResult(String s, int start, boolean [][] isPa) {
      ArrayList&lt;ArrayList<String>> pa = new ArrayList&lt;ArrayList<String>>();</p>

<pre><code>  if(start == s.length())
  {
      pa.add(new ArrayList&lt;String&gt;());
      return pa;
  }       
  for( int i = start; i &lt; s.length(); i++)
  {
      if (isPa[start][i])
          for(ArrayList&lt;String&gt; subPa : printResult(s, i+1, isPa))
          {
              subPa.add(0, s.substring(start, i+1));
              pa.add(subPa);
          }
  }
  return pa;
</code></pre>

<p>  }
  public static void main(String[] args) {
      // TODO Auto-generated method stub
      Palindrome palindrome  = new Palindrome();
      String s=&ldquo;11bbcdcw&rdquo;;
      ArrayList&lt;ArrayList<String>> result = palindrome.partition(s);
  }
}
```</p></li>
<li>注意更新isPa[][]的顺序。
``` java Leetcode132.java
public int minCut(String s) {
  if (s == null || s.length() == 0)
     return 0; <br/>
  int dpMin[] = new int[s.length()];
  for (int i = 0; i &lt; s.length(); i++)
      dpMin[i] = i; <br/>
  boolean[][] isPa = new boolean[s.length()][s.length()];
  for (int j = 0; j &lt; s.length(); j++) {
      for (int i = j; i >= 0; i&mdash;)
          if ((s.charAt(i) == s.charAt(j) &amp;&amp; (j &ndash; i &lt; 2 || isPa[i + 1][j &ndash; 1]))) {
              isPa[i][j] = true;
              if (i > 0)
                  dpMin[j] = Math.min(dpMin[j], 1 + dpMin[i &ndash; 1]);
              else
                  dpMin[j] = 0;
          }
  }</li>
</ul>


<p>return dpMin[s.length() &ndash; 1];
}
```</p>

<p>reference:  <br/>
<a href="http://discuss.leetcode.com/questions/1265/palindrome-partitioning">http://discuss.leetcode.com/questions/1265/palindrome-partitioning</a>  <br/>
<a href="http://discuss.leetcode.com/questions/1266/palindrome-partitioning-ii">http://discuss.leetcode.com/questions/1266/palindrome-partitioning-ii</a></p>

<p>现阶段全部笨办法，有空看看别人的优化思路吧（700ms距离36ms也许是世界上最遥远的距离）。 <br/>
<a href="http://www.cnblogs.com/shawnhue/archive/2013/05/19/leetcode_132.html">http://www.cnblogs.com/shawnhue/archive/2013/05/19/leetcode_132.html</a></p>
]]></content>
  </entry>
  
</feed>
