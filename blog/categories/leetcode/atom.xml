<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Leetcode | ArtemisYY's Blog]]></title>
  <link href="http://ArtemisYY.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://ArtemisYY.github.io/"/>
  <updated>2013-07-31T22:22:02+08:00</updated>
  <id>http://ArtemisYY.github.io/</id>
  <author>
    <name><![CDATA[ArtemisYY]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Best Time to Buy and Sell Stock]]></title>
    <link href="http://ArtemisYY.github.io/blog/2013/07/31/best-time-to-buy-and-sell-stock/"/>
    <updated>2013-07-31T17:02:00+08:00</updated>
    <id>http://ArtemisYY.github.io/blog/2013/07/31/best-time-to-buy-and-sell-stock</id>
    <content type="html"><![CDATA[<p>三道题(Leetcode 121 —— 123) <br/>
Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>

<ul>
<li>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</li>
<li>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>
<li>Design an algorithm to find the maximum profit. You may complete at most two transactions.</li>
</ul>


<p>=================================================================================
解题思路：       <br/>
(1) 寻找序列整数的最大差，且小数出现在前面。 <br/>
(2) 寻找连续递增空间。 <br/>
(3) 将数组(0——i, i+1——n-1)两部分，left[i] 和 right[j]分别记录0——i, j——n-1两部分可获取的最大利润</p>

<p>```java Leetcode121.java
//elegent code
public int maxProfit(int[] prices) {</p>

<pre><code> if(prices.length &lt; 2)
    return 0;
 int max = 0;
 int distance = 0;
 for( int i = 1; i &lt; prices.length; i++)
 {
distance = prices[i] - prices[i-1] + Math.max(distance, 0);
max = (distance &gt; max) ? distance :max;
 }
return max;
</code></pre>

<p>}
// my ugly code
public int maxProfit(int[] prices) {</p>

<pre><code>  if(prices.length &lt; 2)
    return 0;
  int max = 0;
  int min = prices[0];
  for( int i = 1; i &lt; prices.length; i++)
  {
if(prices[i] - min &gt; max)
   max = prices[i] - min;
min = (prices[i] &lt; min ) ? prices[i] : min;
  }
  return max;
</code></pre>

<p> }
<code>
</code>java Leetcode122.java
public int maxProfit(int[] prices) {</p>

<p>  if(prices.length &lt; 2)</p>

<pre><code> return 0;
</code></pre>

<p>  int max = 0;
  int start = prices[0];
  for( int i = 1; i &lt; prices.length; i++ )
  {</p>

<pre><code>  if( prices[i]- prices[i-1] &gt; 0)
 continue;
  max += prices[i-1] - start;
  start = prices[i];
</code></pre>

<p>  }</p>

<p>  max += prices[prices.length &ndash; 1] -start;
  return max;</p>

<pre><code>}
</code></pre>

<p>}
<code>
</code>java Leetcode123.java
public int maxProfit(int[] prices) {</p>

<pre><code>if( prices.length &lt; 2)
return 0;
int left[] = new int[prices.length];
int right[] = new int [prices.length];
int min = prices[0];
int maxP = 0;
left[0] = 0;
for( int i = 1; i &lt; prices.length; i++)
{
left[i] = Math.max(left[i-1], prices[i] - min) ;
if( prices[i] &lt; min)
    min = prices[i];
}
right[prices.length - 1] = 0;
int max = prices[prices.length -1];
for( int i = prices.length-2; i&gt;=0; i--)
{
right[i] = Math.max(right[i+1], max - prices[i] ) ;
if( prices[i] &gt; max)
    max = prices[i];
}

maxP = Math.max(left[prices.length -1], right[0]);
for( int i=0; i&lt; prices.length-2; i++)
    if(maxP &lt; left[i]+ right[i+1])
    maxP = left[i]+ right[i+1];

return maxP;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sum Root to Leaf Numbers]]></title>
    <link href="http://ArtemisYY.github.io/blog/2013/07/31/sum-root-to-leaf-numbers/"/>
    <updated>2013-07-31T16:34:00+08:00</updated>
    <id>http://ArtemisYY.github.io/blog/2013/07/31/sum-root-to-leaf-numbers</id>
    <content type="html"><![CDATA[<p>(Leetcode 129)   <br/>
Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. <br/>
An example is the root-to-leaf path 1->2->3 which represents the number 123.
Find the total sum of all root-to-leaf numbers. <br/>
For example,</p>

<pre><code>  1
 / \
2   3
</code></pre>

<p>The root-to-leaf path 1->2 represents the number 12. <br/>
The root-to-leaf path 1->3 represents the number 13. <br/>
Return the sum = 12 + 13 = 25.</p>

<p>===================================================================================
解题思路： 递归求解。叶结点返回sum，否则每下一层sum*10+node.val. 简单题.</p>

<p>```java Leetcode129.java
public int sumNumbers(TreeNode root) {</p>

<pre><code>        // Start typing your Java solution below
        // DO NOT write main() function


     int prefix = 0;
     return calculateSum( root,  prefix );

    }
</code></pre>

<p>int calculateSum(TreeNode root, int prefix)
{</p>

<pre><code>if( root == null)
   return 0;

prefix = prefix*10 + root.val;
if( root.left == null &amp;&amp; root.right == null)
   return prefix;
return calculateSum(root.left, prefix) + calculateSum(root.right, prefix);
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Palindrome Partitioning]]></title>
    <link href="http://ArtemisYY.github.io/blog/2013/07/27/leetcode-131-and-132-palindrome-partitioning/"/>
    <updated>2013-07-27T17:51:00+08:00</updated>
    <id>http://ArtemisYY.github.io/blog/2013/07/27/leetcode-131-and-132-palindrome-partitioning</id>
    <content type="html"><![CDATA[<p>两道题(Leetcode 121 &ndash; 123).<br/>
Given a string s, partition s such that every substring of the partition is a palindrome.<br/>
   1. Return all possible palindrome partitioning of s. <br/>
   2. Return the minimum cuts needed for a palindrome partitioning of s.</p>

<pre><code>For example, given s = "aab",  
1. Return [["aa","b"],["a","a","b"]]  
2. Return 1 since the palindrome partitioning ["aa","b"] could be produced using 1 cut.
</code></pre>

<p>===================================================================================
解题思路，动态规划：(和矩阵链相乘时，使乘法次数达到最小的运算顺序思路类似。)<br/>
这题比较有意思的是，两个动态规划的思路嵌在一起了。   <br><br>
  1. 用isPa[i][j]矩阵记录S.subString(i,j)是否为回文。 <br/>
  2. 针对不同的问题，根据isPa[i][j]矩阵输出不同结果： <br/>
   + 详细分割串（递归输出）：Start 到 End的所有回文分割串是Start到i,i到End的所有回文分割方法的组合。<br/>
   + 最小分割次数（DP）：用dpMin[j]记录s.subString(0,j)的最小分割次数。</p>

<pre><code>  dpMin[j] = Min{dpMin[j], 1+dpMin[i-1]} （i在0——j， 且s.subString(i,j)为回文）
</code></pre>

<p>===================================================================================</p>

<ul>
<li><p>注意递归输出所有可能的划分时的思路。
```java Leetcode131.java
public class Palindrome {</p>

<p>  public ArrayList&lt;ArrayList<String>> partition(String s) {
      if( s == null || s.length() == 0)
          return new ArrayList&lt;ArrayList<String>>();</p>

<pre><code>  boolean [][] isPa = new boolean[s.length()][s.length()];
  for( int i=0; i&lt;s.length(); i++)
  {
      isPa[i][i] = true;
  }
  for( int d = 1; d &lt; s.length(); d++)
      for( int i = 0; i &lt; s.length()-d; i++)
      {
          int j = i+d;
          if ( d == 1 )
          {
              isPa[i][j] = (s.charAt(i) == s.charAt(j));
          }
          else {
              isPa[i][j] = (s.charAt(i)== s.charAt(j)) &amp;&amp; isPa[i+1][j-1];
          }
      }
  return printResult(s, 0, isPa);
</code></pre>

<p>  } <br/>
  public ArrayList&lt;ArrayList<String>> printResult(String s, int start, boolean [][] isPa) {
      ArrayList&lt;ArrayList<String>> pa = new ArrayList&lt;ArrayList<String>>();</p>

<pre><code>  if(start == s.length())
  {
      pa.add(new ArrayList&lt;String&gt;());
      return pa;
  }       
  for( int i = start; i &lt; s.length(); i++)
  {
      if (isPa[start][i])
          for(ArrayList&lt;String&gt; subPa : printResult(s, i+1, isPa))
          {
              subPa.add(0, s.substring(start, i+1));
              pa.add(subPa);
          }
  }
  return pa;
</code></pre>

<p>  }
  public static void main(String[] args) {
      // TODO Auto-generated method stub
      Palindrome palindrome  = new Palindrome();
      String s=&ldquo;11bbcdcw&rdquo;;
      ArrayList&lt;ArrayList<String>> result = palindrome.partition(s);
  }
}
```</p></li>
<li>注意更新isPa[][]的顺序。
``` java Leetcode132.java
public int minCut(String s) {
  if (s == null || s.length() == 0)
     return 0; <br/>
  int dpMin[] = new int[s.length()];
  for (int i = 0; i &lt; s.length(); i++)
      dpMin[i] = i; <br/>
  boolean[][] isPa = new boolean[s.length()][s.length()];
  for (int j = 0; j &lt; s.length(); j++) {
      for (int i = j; i >= 0; i&mdash;)
          if ((s.charAt(i) == s.charAt(j) &amp;&amp; (j &ndash; i &lt; 2 || isPa[i + 1][j &ndash; 1]))) {
              isPa[i][j] = true;
              if (i > 0)
                  dpMin[j] = Math.min(dpMin[j], 1 + dpMin[i &ndash; 1]);
              else
                  dpMin[j] = 0;
          }
  }</li>
</ul>


<p>return dpMin[s.length() &ndash; 1];
}
```</p>

<p>reference:  <br/>
<a href="http://discuss.leetcode.com/questions/1265/palindrome-partitioning">http://discuss.leetcode.com/questions/1265/palindrome-partitioning</a>  <br/>
<a href="http://discuss.leetcode.com/questions/1266/palindrome-partitioning-ii">http://discuss.leetcode.com/questions/1266/palindrome-partitioning-ii</a></p>

<p>现阶段全部笨办法，有空看看别人的优化思路吧（700ms距离36ms也许是世界上最遥远的距离）。 <br/>
<a href="http://www.cnblogs.com/shawnhue/archive/2013/05/19/leetcode_132.html">http://www.cnblogs.com/shawnhue/archive/2013/05/19/leetcode_132.html</a></p>
]]></content>
  </entry>
  
</feed>
